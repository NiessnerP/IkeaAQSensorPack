esphome:
  name: "${name}"
  friendly_name: "${friendly_name}"
  name_add_mac_suffix: true

  on_boot:
    priority: 600
    then:
      - lambda: |-
          if (!id(eCO2_calibration).state) {
            ESP_LOGI("calib", "Kalibrierschalter AUS – Baseline wird beim Boot nicht gesetzt.");
            return;
          }

          std::string val = id(eCO2_Baseline).state;
          if (val.length() == 6 && val[0] == '0' && val[1] == 'x') {
            uint16_t baseline = (uint16_t) strtol(val.c_str(), nullptr, 16);
            ESP_LOGI("calib", "Re-applying CCS811 Baseline 0x%04X", baseline);
            id(ccs811_sensor).set_baseline(baseline);
          }

logger:
  logs:
    sensor: none
    binary_sensor: none
    pm1006: none
    bme280_i2c: none
    ccs811: none

switch:
  - platform: template
    name: "CCS811 Kalibrierung abgeschlossen"
    id: eCO2_calibration
    entity_category: config
    optimistic: true
    restore_mode: RESTORE_DEFAULT_OFF

text:
  - platform: template
    name: "CCS811 eCO2 Baseline"
    id: eCO2_Baseline
    mode: text
    entity_category: config
    optimistic: true
    restore_value: true
    min_length: 6
    max_length: 6

    on_value:
      then:
        - lambda: |-
            if (!id(eCO2_calibration).state) {
              ESP_LOGI("calib", "Schalter AUS – keine Baseline gesetzt.");
              return;
            }

            std::string val = x;

            if (val.length() != 6 || val[0] != '0' || val[1] != 'x') {
              ESP_LOGE("calib", "Ungültiges Format! Nutze: 0x0000");
              return;
            }

            uint16_t baseline = (uint16_t) strtol(val.c_str(), nullptr, 16);
            ESP_LOGI("calib", "Setze CCS811 Baseline: 0x%04X", baseline);

            id(ccs811_sensor).set_baseline(baseline);

api:
  encryption:
    key: ${api_key}

http_request:
  verify_ssl: false
  timeout: 10s

ota:
  - platform: http_request

update:
  - platform: http_request
    name: "Firmware Update (GitHub)"
    entity_category: config
    source: https://github.com/NiessnerP/IkeaAQSensorPack/releases/latest/download/firmware.bin

wifi:
  ssid: ${wifi_ssid}
  password: ${wifi_password}

  ap:
    ssid: "${name}-fallback"

captive_portal:

web_server:
  port: 80

uart:
  - rx_pin: ${uart_rx}
    baud_rate: 9600

i2c:
  sda: ${i2c_sda}
  scl: ${i2c_scl}
  id: bus_a

binary_sensor:
  - platform: gpio
    name: Fan
    id: fan
    pin:
      number: ${fan_input}
      inverted: true

sensor:
  - platform: bme280_i2c
    temperature:
      name: "BME280 Temperature"
      id: bme280_temperature
    pressure:
      name: "BME280 Pressure"
      id: bme280_pressure
    humidity:
      name: "BME280 Humidity"
      id: bme280_humidity
    i2c_id: bus_a
    address: 0x76
    update_interval: ${update_interval}

  - platform: ccs811
    id: ccs811_sensor

    eco2:
      name: "CCS811 eCO2 Value"
      on_value:
        then:
          - lambda: |-
              if (!id(eCO2_calibration).state) {
                ESP_LOGW("ccs811", "eCO2: %.0f ppm", x);
              }

    tvoc:
      name: "CCS811 TVOC"
      on_value:
        then:
          - lambda: |-
              if (!id(eCO2_calibration).state) {
                ESP_LOGW("ccs811", "TVOC: %.0f ppb", x);
              }

    i2c_id: bus_a
    address: 0x5A
    update_interval: ${update_interval}
    temperature: bme280_temperature
    humidity: bme280_humidity

  - platform: pm1006
    id: aq_sensor
    pm_2_5:
      name: PMS 2.5µg

  - platform: adc
    id: light_sensor
    name: "Light in mV"
    pin: ${lightlvl_input}
    raw: true
    update_interval: 1s
